{"version":3,"sources":["../../../src/models/authentication/Authentication.js"],"names":["removeTokensFromUrl","newUrl","document","location","window","history","replaceState","title","Authentication","types","model","processing","selectedAuthenticationProviderId","actions","self","runInAction","fn","cleanup","selectedAuthenticationProvider","clearTokens","_","forEach","localStorageKeys","keyValue","storage","removeItem","setSelectedAuthenticationProviderId","authenticationProviderId","getIdToken","idTokenFromUrl","idTokenFromLocal","getItem","appIdToken","idToken","getIdTokenInfo","tokenStatus","decodedIdToken","expiresAt","get","Date","now","e","status","saveIdToken","setItem","login","username","password","shouldCollectUserNamePassword","result","isEmpty","boom","incorrectImplementation","appRunner","run","logout","autoLogout","views","isCognitoUserPool","type","authenticationProviderPublicConfigsStore","toAuthenticationProviderFromId","credentialHandlingType","registerContextItems","appContext","authentication","create"],"mappings":"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","sourcesContent":["/*\n *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\").\n *  You may not use this file except in compliance with the License.\n *  A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n *  or in the \"license\" file accompanying this file. This file is distributed\n *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n *  express or implied. See the License for the specific language governing\n *  permissions and limitations under the License.\n */\n\nimport _ from 'lodash';\nimport { getEnv, types } from 'mobx-state-tree';\n\nimport jwtDecode from 'jwt-decode';\nimport { storage, getFragmentParam, removeFragmentParams } from '../../helpers/utils';\nimport { setIdToken } from '../../helpers/api';\n\nimport localStorageKeys from '../constants/local-storage-keys';\nimport { boom } from '../../helpers/errors';\n\nfunction removeTokensFromUrl() {\n  const newUrl = removeFragmentParams(document.location, ['id_token', 'access_token', 'token_type', 'expires_in']);\n  window.history.replaceState({}, document.title, newUrl);\n}\n\n// ==================================================================\n// Login model\n// ==================================================================\nconst Authentication = types\n  .model('Authentication', {\n    processing: false,\n    selectedAuthenticationProviderId: '',\n  })\n  .actions(self => ({\n    runInAction(fn) {\n      return fn();\n    },\n\n    // this method is called by the Cleaner\n    cleanup() {\n      if (self.selectedAuthenticationProvider) {\n        // give selected authentication provider a chance to do its own cleanup\n        self.selectedAuthenticationProvider.cleanup();\n      }\n      self.clearTokens();\n    },\n\n    clearTokens() {\n      _.forEach(localStorageKeys, keyValue => storage.removeItem(keyValue));\n    },\n\n    setSelectedAuthenticationProviderId(authenticationProviderId) {\n      self.selectedAuthenticationProviderId = authenticationProviderId;\n    },\n\n    async getIdToken() {\n      // The id token would be in URL in case of SAML redirection.\n      // The name of the token param is \"id_token\" in that case (instead of \"appIdToken\"), if the token is\n      // issued by Cognito.\n      // Also the id_token is returned via URL fragment i.e, with # instead of query param something like\n      // https://web.site.url/#id_token=blabla instead of\n      // https://web.site.url?idToken=blabla\n      // TODO: Make the retrieval of id token from query string param or fragment param (or any other mechanism)\n      // dynamic based on the authentication provider. Without that, the following code will only work for\n      // any auth providers that set id token either in local storage as \"appIdToken\" or deliver to us\n      // via URL fragment parameter as \"id_token\".\n      // This code will NOT work for auth providers issuing id token and delivering via any other mechanism.\n      const idTokenFromUrl = getFragmentParam(document.location, 'id_token');\n      if (idTokenFromUrl) removeTokensFromUrl(); // we remove the idToken from the url for a good security measure\n\n      const idTokenFromLocal = storage.getItem(localStorageKeys.appIdToken);\n\n      const idToken = idTokenFromUrl || idTokenFromLocal;\n      return idToken;\n    },\n\n    async getIdTokenInfo() {\n      const idToken = await self.getIdToken();\n\n      let tokenStatus = 'notFound';\n      let decodedIdToken;\n      if (idToken) {\n        try {\n          decodedIdToken = jwtDecode(idToken);\n          // Check if the token is expired\n          // decodedIdToken.exp is epoch time in SECONDS\n          // ( - See \"exp\" claim JWT RFC - https://tools.ietf.org/html/rfc7519#section-4.1.4 for details\n          //   - the claim is in \"NumericDate\" format.\n          //   - NumericDate is Epoch in Seconds - https://ldapwiki.com/wiki/NumericDate )\n          //\n          // Date.now() returns epoch time in MILLISECONDS\n          const expiresAt = _.get(decodedIdToken, 'exp', 0) * 1000;\n          if (Date.now() >= expiresAt) {\n            tokenStatus = 'expired';\n          } else {\n            tokenStatus = 'notExpired';\n          }\n        } catch (e) {\n          // the token may not be a well-formed JWT toekn in case of any error\n          // decoding it\n          tokenStatus = 'corrupted';\n        }\n      }\n      return {\n        idToken,\n        decodedIdToken,\n        status: tokenStatus,\n      };\n    },\n\n    async saveIdToken(idToken) {\n      storage.setItem(localStorageKeys.appIdToken, idToken);\n      const decodedIdToken = idToken && jwtDecode(idToken);\n      setIdToken(idToken, decodedIdToken);\n    },\n\n    async login({ username, password }) {\n      if (self.shouldCollectUserNamePassword) {\n        const result = await self.selectedAuthenticationProvider.login({\n          username,\n          password,\n          authenticationProviderId: self.selectedAuthenticationProviderId,\n        });\n        const { idToken } = result || {};\n        if (_.isEmpty(idToken)) {\n          throw boom.incorrectImplementation(\n            `There is a problem with the implementation of the server side code. The id token is not returned.`,\n          );\n        }\n\n        await self.saveIdToken(idToken);\n\n        const appRunner = getEnv(self).appRunner;\n        await appRunner.run();\n      } else {\n        // If we do no need to collect credentials from the user then just call login method of the selected authentication provider without any arguments\n        // The selected auth provider will then take care of rest of the login flow (such as redirecting to other identity provider etc)\n        await self.selectedAuthenticationProvider.login();\n      }\n    },\n    async logout({ autoLogout = false } = {}) {\n      self.cleanup();\n      return self.selectedAuthenticationProvider.logout({ autoLogout });\n    },\n  }))\n  .views(self => ({\n    get isCognitoUserPool() {\n      return self.selectedAuthenticationProvider.type === 'cognito_user_pool';\n    },\n    get selectedAuthenticationProvider() {\n      const authenticationProviderPublicConfigsStore = getEnv(self).authenticationProviderPublicConfigsStore;\n      return authenticationProviderPublicConfigsStore.toAuthenticationProviderFromId(\n        self.selectedAuthenticationProviderId,\n      );\n    },\n\n    get shouldCollectUserNamePassword() {\n      const selectedAuthenticationProvider = self.selectedAuthenticationProvider;\n      return selectedAuthenticationProvider && selectedAuthenticationProvider.credentialHandlingType === 'submit';\n    },\n  }));\n\nfunction registerContextItems(appContext) {\n  appContext.authentication = Authentication.create({}, appContext);\n}\n\nexport { Authentication, registerContextItems };\n"],"file":"Authentication.js"}